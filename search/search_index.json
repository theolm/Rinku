{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Rinku","text":"<p>Rinku is a lightweight Kotlin Multiplatform library designed to simplify deep link handling across iOS and Android platforms. By abstracting platform-specific details, Rinku enables developers to manage deep links in a unified manner, enhancing code reuse and maintaining consistency across platforms.</p>"},{"location":"#summary","title":"Summary","text":""},{"location":"#1-setup","title":"1. Setup","text":""},{"location":"#2-firing-internal-deep-links","title":"2. Firing Internal Deep Links","text":""},{"location":"#3-type-safe-parameters","title":"3. Type-safe parameters","text":""},{"location":"#4-internal-deeplink-filter","title":"4. Internal deeplink filter","text":""},{"location":"#5-demonstrative-samples","title":"5. Demonstrative Samples","text":""},{"location":"1-setup/","title":"Setup","text":"<p>This guide presupposes the prior configuration of deeplinks within the native platforms:</p> <ul> <li>Android deeplink</li> <li>iOS URL scheme</li> <li>iOS universal link</li> </ul>"},{"location":"1-setup/#installation-process","title":"Installation Process","text":"<p>The library is available via Maven Central <pre><code>implementation(\"dev.theolm:rinku:&lt;latest_version&gt;\")\nimplementation(\"dev.theolm:rinku-compose-ext:&lt;latest_version&gt;\")\n</code></pre></p>"},{"location":"1-setup/#gradle-configuration","title":"Gradle Configuration","text":"<p>In your <code>build.gradle.kts</code> file you need to: - Include Rinku in commonMain as an api (this is required to export it to iOS) - If you are using Compose multiplatform, also include the compose-extensions - Export the lib in the ios framework</p> <p>Example: <pre><code>kotlin {\n    ...\n    listOf(\n        iosX64(),\n        iosArm64(),\n        iosSimulatorArm64()\n        // Specify iOS targets\n    ).forEach { iosTarget -&gt;\n        iosTarget.binaries.framework {\n            // Export of Rinku library to the iOS framework\n            export(\"dev.theolm:rinku:&lt;latest_version&gt;\")\n            ...\n        }\n    }\n    ...\n    sourceSets {\n        commonMain.dependencies {\n            api(\"dev.theolm:rinku:&lt;latest_version&gt;\")\n\n            // For compose multiplatform projects\n            implementation(\"dev.theolm:rinku-compose-ext:&lt;latest_version&gt;\")\n        }\n    }\n}\n</code></pre></p>"},{"location":"1-setup/#android-setup","title":"Android setup","text":"<p>The library provides two types of initialization (KMP only and Compose), you should use the one that fit your needs.</p>"},{"location":"1-setup/#kmp-only","title":"KMP only","text":"<p>On the Android app, inside the <code>onCreate</code>, call the extension <code>RinkuInit()</code>.</p> <pre><code>class MainActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        RinkuInit()\n        setContent {\n            App()\n        }\n    }\n}\n</code></pre>"},{"location":"1-setup/#with-compose-multiplatform","title":"With Compose multiplatform","text":"<p>First make sure you included the <code>rinku-compose-ext</code>in your <code>commonMain</code>. On the Android app inside the <code>setContent</code> use <code>ComponentActivity.Riku</code> extension to wrap the root of your app.</p> <pre><code>class MainActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n\n        setContent {\n            Rinku {\n                App()\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"1-setup/#ios-setup","title":"iOS setup","text":"<p>For the iOS platform, deep links are processed within the AppDelegate or SceneDelegate, contingent on the project\u2019s configuration. The primary objective is to intercept the platform-specific deep link and relay it as an argument to Rinku\u2019s handleDeepLink(url) method.</p> <p>Example within AppDelegate:</p> <pre><code>@UIApplicationMain\nclass AppDelegate: NSObject, UIApplicationDelegate {\n    ...\n    // Provide deepLinkFilter and deepLinkMapper if needed\n    let rinku = RinkuIos.init(deepLinkFilter: nil, deepLinkMapper: nil)\n    func application(_ app: UIApplication, open url: URL, options: [UIApplication.OpenURLOptionsKey : Any] = [:]) -&gt; Bool {\n        rinku.onDeepLinkReceived(url: url.absoluteString)\n        return true\n    }\n\n    func application(_ application: UIApplication, continue userActivity: NSUserActivity, restorationHandler: @escaping ([UIUserActivityRestoring]?) -&gt; Void) -&gt; Bool {\n        if userActivity.activityType == NSUserActivityTypeBrowsingWeb, let url = userActivity.webpageURL {\n            let urlString = url.absoluteString\n            rinku.onDeepLinkReceived(userActivity: userActivity)\n        }\n        return true\n    }\n    ...\n}\n</code></pre>"},{"location":"1-setup/#common-setup","title":"Common setup","text":"<p>In the common code you just need to listen to the deeplinks and treat them as you need. Once the application (Android or iOS) recieves a deeplink it will parse it into a <code>Deeplink</code> data class and pass it into the listener. Use the listener that suite your project.</p>"},{"location":"1-setup/#using-compose","title":"Using Compose","text":"<p>Example RootApp in commonMain:</p> <pre><code>@Composable\nfun RootApp() {\n    var deepLink by remember { mutableStateOf&lt;DeepLink?&gt;(null) }\n    DeepLinkListener { deepLink = it }\n    MainScreen(deepLink)\n}\n</code></pre>"},{"location":"1-setup/#kmp-only_1","title":"KMP only","text":"<p>Just use the suspend function <code>listenForDeepLinks</code> and react as you will.</p> <p>Example inside a Decompose component:</p> <pre><code>class AppComponentImpl(\n    private val initialStack: List&lt;Config&gt; = emptyList(),\n    componentContext: ComponentContext,\n) : AppComponent, ComponentContext by componentContext {\n    private val navigation = StackNavigation&lt;Config&gt;()\n\n    init {\n        launch { initDeepLinkListener() }\n    }\n\n    private suspend fun initDeepLinkListener() {\n        listenForDeepLinks {\n            navigation.replaceAll(\n                *it.toScreenStack().toTypedArray()\n            )\n        }\n    }\n}\n</code></pre>"},{"location":"2-firing-internal-deeplink/","title":"Firing Internal Deeplink","text":"<p>Rinku simplifies the process of triggering internal deep links directly from your common Kotlin Multiplatform (KMP) code. This feature allows you to easily navigate within your application using a unified approach across all platforms.</p>"},{"location":"2-firing-internal-deeplink/#triggering-a-deep-link","title":"Triggering a Deep Link","text":"<p>To invoke an internal deep link within your application, use the handleDeepLink method provided by Rinku. This method accepts a single parameter: the URL of the deep link you wish to trigger.</p> <pre><code>Rinku.handleDeepLink(\"https://test.deeplink/path?query=true\")\n</code></pre> <p>In this example, https://test.deeplink/path?query=true represents the URL of the deep link. The URL scheme, path, and query parameters should be replaced with values that are relevant to your application\u2019s routing structure.</p> <p>By leveraging Rinku\u2019s handleDeepLink method, you can enhance your application\u2019s navigation capabilities, making it easier to programmatically direct users to specific areas of your app from shared KMP code.</p>"},{"location":"3-type-safe-parameters/","title":"Type-safe parameters","text":"<p>Rinku supports get and create typesafe parameters leveraging the kotlinx-serialization. In order to use the following functions the app/module needs to setup kotlinx-serialization.</p>"},{"location":"3-type-safe-parameters/#getting-parameters","title":"Getting parameters","text":"<p>Use the <code>DeepLink</code> extension <code>&lt;T&gt; DeepLink.getParameter</code> and pass the key of the argument in the URL query and the KSerializer of the correspoinding kotlin class.</p> <p>example:</p> <pre><code>@Serializable\ndata class Name(val name: String)\n\nfun example() {\n    val url = \"https://theolm/dev/path?test={\"name\": \"Theo\"}\"\n    val deepLink = DeepLink(url)\n\n    val param : Name = deepLink.getParameter(name = \"wrong name\", kSerializer = Name.serializer())\n}\n</code></pre>"},{"location":"3-type-safe-parameters/#build-a-url-using-serializable-classes","title":"Build a URL using Serializable classes","text":"<p>Rinku also provides the helper funcion <code>Rinku.buildUrl</code> that facilitates the creation of internal deeplinks with parameters. In order to do that you first need to create the URL and fire the deeplink.</p> <p>example:</p> <pre><code>@Serializable\ndata class Name(val name: String)\n\nfun example() {\n    val testModel = Name(\"Testing\")\n    val testParam = DeepLinkParam(\n        \"testParam\",\n        testModel,\n        Name.serializer()\n    )\n    val url = Rinku.buildUrl(TestUrl, testParam)\n    Rinku.handleDeepLink(url)\n}\n</code></pre>"},{"location":"4-internal-deeplink-filter/","title":"Internal Deeplink Filter","text":"<p>Rinku provides a simple way to filter unwanted external deeplinks. Instead of filter deeplinks providing specific paths in the AndroidManifest and info.plist you implment the interface <code>DeepLinkFilter</code> and pass it into Rinku initialization. With this configuration, when the app recieves a not valid deeplink rinku is not going to handle it. This is usefull to block internal deeplinks from external access without having to include it in platform specific configuration.</p>"},{"location":"4-internal-deeplink-filter/#deeplink-mapper","title":"Deeplink mapper","text":"<p>This feature is used to map external deeplinks into internal deeplinks. Use case 1: Android and ios application has different deeplinks registered in marketing campaigns. The mapper can be used to map the external deeplink to unique internal deeplink, and the application can handle the deeplink accordingly in a unified way. Use case 2: External deeplink does not have the full path to represent a valid stack. Use the mapper to provide the full stack.</p> <pre><code>// External deeplink rinku://dev.theolm/screenC/\n// The deeplink is missing A and B\n\n// Implement and pass the mapper into Rinku init. This way the external deeplink will be mapped and can be handle in the commonMain.\nobject ExampleMapper : DeepLinkMapper {\n    override fun map(url: String): String {\n        return if (url == \"rinku://dev.theolm/screenC/\") {\n            return \"rinku://dev.theolm/screenA/screenB/screenC/\"\n        } else {\n            url\n        }\n    }\n}\n</code></pre>"},{"location":"5-demonstrative-samples/","title":"Demonstrative Samples","text":"<p>The library includes two illustrative examples utilizing the foremost multiplatform navigation libraries: Voyager and Decompose</p> <ul> <li>Voyager sample</li> <li>Decompose sample</li> </ul> <p>Note: Only the Voyager sample includes an iOS application. Nonetheless, the setup for Decompose would mirror that of Voyager.</p> <p>Note 2: Both examples are using Compose multiplatform.</p>"}]}